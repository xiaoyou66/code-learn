## 什么是对象

Python 里的所有数据都是以对象形式存在的，无论是简单的数 字类型还是复杂的代码模块。然而，Python 特殊的语法形式巧妙地将实现对象机制的大量 细节隐藏了起来。输入 num = 7 就可以创建一个值为 7 的整数对象，并且将这个对象赋值 给变量 num。事实上，在 Python 中，只有当你想要创建属于自己的对象或者需要修改已有 对象的行为时，才需要关注对象的内部实现细节。

## 使用class定义类

下面我们简单定义一个类，并使用这个类

```python
class Person():
    pass

one = Person()
```

下面我们来使用构造函数，构造函数这里初始化了一个类，然后设置了值

```python
class Person():
    def __init__(self,name):
        self.name = name

one = Person("小游")
print(one.name)
--------
小游
```

## 继承

只需要在类的括号里面加上父类的对象就可以实现继承了

```python
class Father():
    name = "父类"
    def say(self):
        print(self.name)

class Person(Father):
    pass

one = Person()
one.say()
--------
父类
```

## 覆盖方法

在子类中，可以覆盖任何父类的方 法，包括 __init__()

```python
class Father():
    name = "父类"
    def say(self):
        print(self.name)

class Person(Father):
    name = '子类'
    def say(self):
        print(self.name)

one = Person()
one.say()
----------
子类
```

## 添加新方法

子类还可以添加父类中没有的方法。

```python
class Father():
    name = "父类"
    def say(self):
        print(self.name)

class Person(Father):
    name = '子类'
    def say(self):
        print(self.name)
    def hello(self):
        print("hello")

one = Person()
one.hello()
------
hello
```

## 使用super来使用父方法

```python
class Father():
    name = "父类"
    def say(self):
        print(self.name)

class Person(Father):
    name = '子类'
    def say(self):
        super().say()
    def hello(self):
        print("hello")

one = Person()
one.say()
---------
子类
```

## 使用属性对特性进行设置和访问

有一些面向对象的语言支持私有特性。这些特性无法从对象外部直接访问，我们需要编写 getter 和 setter 方法对这些私有特性进行读写操作。

Python 不需要 getter 和 setter 方法，因为 Python 里所有特性都是公开的，使用时全凭自觉。 如果你不放心直接访问对象的特性，可以为对象编写 setter 和 getter 方法。但更具 Python 风格的解决方案是使用属性（property） 。

当我们尝试访问name时会自动调用get_name方法

```python
class Duck():
    def __init__(self, input_name):
        self.hidden_name = input_name
    def get_name(self):
        print('inside the getter')
        return self.hidden_name
    def set_name(self, input_name):
        print('inside the setter')
        self.hidden_name = input_name
    name = property(get_name, set_name)

one = Duck("小鸭子")
one.name
--------
inside the getter
```

另外一个方式就是使用修饰符，下面这个方式和上面是一样的

```python
class Duck():
    def __init__(self, input_name):
        self.hidden_name = input_name
    @property
    def name(self):
        print('inside the getter')
        return self.hidden_name
    @name.setter
    def name(self, input_name):
        print('inside the setter')
        self.hidden_name = input_name

one = Duck("小鸭子")
one.name
```

与直接访问特性相比，使用 property 还有一个巨大的优势：如果你改变了某个特性的定义， 只需要在类定义里修改相关代码即可，不需要在每一处调用修改。

## 使用名称保护代码私有性

前面的 Duck 例子中，为了隐藏内部特性，我们曾将其命名为 hidden_name。其实，Python 对那些需要刻意隐藏在类内部的特性有自己的命名规范：由连续的两个下划线开头（__）

```python
class Duck():
    def __init__(self, input_name):
        self.__name = input_name
    @property
    def name(self):
        print('inside the getter')
        return self.__name
    @name.setter
    def name(self, input_name):
        print('inside the setter')
        self.__name = input_name

one = Duck("小鸭子")
one.name
```

如果我们想访问私有变量，则会报错

```python
print(one.__name)
------
Traceback (most recent call last):
  File "E:/CODE/Python/入门/main.py", line 15, in <module>
    print(one.__name)
AttributeError: 'Duck' object has no attribute '__name'
```

## 方法类型

在类的定义中， self 作为第一个参数的方法都是实例方法（instance method）。它们在 创建自定义类时最常用。实例方法的首个参数是 self，当它被调用时，Python 会把调用该 方法的对象作为 self 参数传入

